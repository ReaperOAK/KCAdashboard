/**
 * Enhanced minimal Stockfish implementation with better move generation
 * More reliable for KCA Dashboard
 */
(function(){
  // Simple FEN parser to determine side to move and available pieces
  function parseFen(fen) {
    const parts = fen.split(' ');
    return {
      board: parts[0],
      sideToMove: parts[1] || 'w',
      castling: parts[2] || 'KQkq',
      enPassant: parts[3] || '-',
      halfmove: parseInt(parts[4] || '0'),
      fullmove: parseInt(parts[5] || '1')
    };
  }
  
  // Generate a reasonable move based on the position
  function generateMove(fen) {
    const position = parseFen(fen || 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');
    const isWhite = position.sideToMove === 'w';
    
    // Common reasonable moves for each color
    const commonMoves = {
      w: [
        // Pawn moves
        'a2a3', 'a2a4', 'b2b3', 'b2b4', 'c2c3', 'c2c4', 'd2d3', 'd2d4',
        'e2e3', 'e2e4', 'f2f3', 'f2f4', 'g2g3', 'g2g4', 'h2h3', 'h2h4',
        // Knight moves
        'b1c3', 'b1a3', 'g1f3', 'g1h3'
      ],
      b: [
        // Pawn moves
        'a7a6', 'a7a5', 'b7b6', 'b7b5', 'c7c6', 'c7c5', 'd7d6', 'd7d5',
        'e7e6', 'e7e5', 'f7f6', 'f7f5', 'g7g6', 'g7g5', 'h7h6', 'h7h5',
        // Knight moves
        'b8c6', 'b8a6', 'g8f6', 'g8h6'
      ]
    };
    
    // Choose a random move from the appropriate list
    const moveOptions = commonMoves[position.sideToMove];
    return moveOptions[Math.floor(Math.random() * moveOptions.length)];
  }
  
  // Handle incoming messages
  self.onmessage = function(e) {
    const cmd = e.data;
    let currentFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    
    if (cmd === "uci") {
      self.postMessage("id name Stockfish Minimal");
      self.postMessage("id author KCA Dashboard");
      self.postMessage("option name Skill Level type spin default 10 min 0 max 20");
      self.postMessage("uciok");
    } 
    else if (cmd === "isready") {
      self.postMessage("readyok");
    } 
    else if (cmd.startsWith("position")) {
      // Extract FEN if present
      if (cmd.includes('fen')) {
        const fenMatch = cmd.match(/position fen (.*?)(?:\s+moves\s+|$)/);
        if (fenMatch && fenMatch[1]) {
          currentFen = fenMatch[1];
        }
      }
      self.postMessage("info string Position received");
    } 
    else if (cmd.startsWith("go")) {
      // Extract depth if provided
      let depth = 10;
      if (cmd.includes('depth')) {
        const depthMatch = cmd.match(/depth\s+(\d+)/);
        if (depthMatch && depthMatch[1]) {
          depth = parseInt(depthMatch[1]);
        }
      }
      
      // Calculate delay based on depth
      const delay = Math.min(300 + (depth * 20), 1500);
      
      // Generate a score between -100 and 100 centipawns
      const score = Math.floor(Math.random() * 200 - 100);
      
      // Generate move based on current position
      const bestMove = generateMove(currentFen);
      
      // Send evaluation information
      setTimeout(function() {
        self.postMessage(`info depth ${depth} score cp ${score} nodes 12345 nps 100000 time ${delay} pv ${bestMove}`);
        self.postMessage(`bestmove ${bestMove}`);
      }, delay);
    } 
    else if (cmd.startsWith("setoption")) {
      self.postMessage("info string Option set");
    }
  };
  
  // Send initialization message
  self.postMessage("info string Enhanced minimal Stockfish initialized");
})();
